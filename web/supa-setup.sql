-- 1. Create Tables if they don't exist
CREATE TABLE IF NOT EXISTS public.tenants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    slug text NOT NULL UNIQUE,
    status text DEFAULT 'active',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    tenant_id bigint REFERENCES public.tenants(id),
    email text,
    username text UNIQUE,
    slug text,
    display_name text,
    bio text,
    status text DEFAULT 'active',
    profile_image text,
    cover_image text,
    theme text DEFAULT 'adaptive',
    link_style text DEFAULT 'glass',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Basic Policies
CREATE POLICY "Public read tenants" ON public.tenants FOR SELECT USING (true);
CREATE POLICY "Public read profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
-- Allow users to insert their *own* profile if the trigger fails or for manual correction? 
-- Usually trigger is SECURITY DEFINER so this isn't strictly needed for sign up, but good for robustness.
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- 2. Trigger Function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
DECLARE
  new_tenant_id bigint;
  user_full_name text;
  user_slug text;
  user_email_prefix text;
BEGIN
  -- Extract info
  user_full_name := COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', split_part(new.email, '@', 1));
  user_email_prefix := split_part(new.email, '@', 1);
  -- Create a clean slug/username from email + random to ensure uniqueness
  user_slug := lower(regexp_replace(user_email_prefix, '[^a-zA-Z0-9]', '', 'g')) || floor(random() * 1000 + 1)::text;

  -- A. Create a default Tenant for the user
  INSERT INTO public.tenants (name, slug, status)
  VALUES (
    COALESCE(user_full_name, 'Minha Loja'),
    user_slug,
    'active'
  )
  RETURNING id INTO new_tenant_id;

  -- B. Create the Profile linked to the Tenant
  INSERT INTO public.profiles (
    id,
    tenant_id, 
    email, 
    username, -- Explicit username column
    slug, 
    display_name, 
    status
  )
  VALUES (
    new.id, -- Important: Link to Auth User ID
    new_tenant_id,
    new.email,
    user_slug, -- Default username is same as slug
    user_slug,
    user_full_name,
    'active'
  );

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Attach the Trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
